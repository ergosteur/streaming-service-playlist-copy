from ytmusicapi import YTMusic
from plexapi.server import PlexServer
import argparse
import csv
import sys
import os

# Argument parser setup
parser = argparse.ArgumentParser(description="Sync YouTube Music playlist to Plex.")
parser.add_argument('--plex-url', required=True, help="Plex server URL")
parser.add_argument('--plex-token', required=True, help="Plex authentication token")
parser.add_argument('--playlist-name', required=True, help="Name for the Plex playlist")
parser.add_argument('--youtube-playlist-id', required=True, help="YouTube Music playlist ID")
parser.add_argument('--oauth-json-path', required=True, help="Path to the oauth.json file generated by `ytmusicapi oauth`")
parser.add_argument('--plex-library', default='Music', help="Plex library section name (default: Music)")
parser.add_argument('--append', action='store_true', help="Append to the existing Plex playlist if it exists")
parser.add_argument('--replace', action='store_true', help="Replace the existing Plex playlist if it exists")
parser.add_argument('--unmatched-output', help="File to save unmatched YouTube track info")
parser.add_argument('--unmatched-format', choices=['text', 'csv'], default='text', help="Format of unmatched output file (text or csv)")
parser.add_argument('--force-album-match', choices=['exact', 'fuzzy'], help="Enforce exact or fuzzy album match for track matching in Plex")

# Stub for deprecated cookies path argument
parser.add_argument('--cookies-path', help="Deprecated. Please use `ytmusicapi oauth` to generate an oauth.json file.")

args = parser.parse_args()

# Display warning if --cookies-path is used
if args.cookies_path:
    print("Warning: --cookies-path is deprecated. Please use `ytmusicapi oauth` to generate an oauth.json file.")

# Initialize Plex server
plex = PlexServer(args.plex_url, args.plex_token)
music_library = plex.library.section(args.plex_library)

# Initialize YTMusic with OAuth JSON for authenticated access
if not os.path.exists(args.oauth_json_path):
    sys.exit(f"OAuth file not found at {args.oauth_json_path}. Please run `ytmusicapi oauth` to generate this file.")
ytmusic = YTMusic(args.oauth_json_path)

# Fetch tracks from YouTube Music playlist
def get_youtube_music_tracks(playlist_id):
    playlist = ytmusic.get_playlist(playlist_id)
    tracks = []
    for track in playlist['tracks']:
        album_name = track['album']['name'] if track.get('album') and track['album'].get('name') else 'Unknown Album'
        tracks.append({
            'name': track['title'],
            'artist': track['artists'][0]['name'],
            'album': album_name
        })
    return tracks

# Enhanced function to search for track by artist, album, and track title in Plex with exact or fuzzy album match
def find_track_in_plex(artist_name, track_name, album_name=None):
    artist_results = [
        artist for artist in music_library.search(title=artist_name)
        if artist.type == 'artist' and artist.title.lower() == artist_name.lower()
    ]

    if not artist_results:
        artist_results = [
            artist for artist in music_library.search(title=artist_name)
            if artist.type == 'artist' and artist_name.lower() in artist.title.lower()
        ]

    if not artist_results:
        print(f"No results found for artist '{artist_name}'.")
        return None

    for artist in artist_results:
        for album in artist.albums():
            if album_name != 'Unknown Album':
                if args.force_album_match == 'exact' and album.title.lower() != album_name.lower():
                    continue
                elif args.force_album_match == 'fuzzy' and album_name.lower() not in album.title.lower():
                    continue

            for track in album.tracks():
                if track.title.lower() == track_name.lower():
                    print(f"Match found: {track.title} in album '{album.title}' by '{artist.title}'")
                    return track

    if not args.force_album_match or album_name == 'Unknown Album':
        for artist in artist_results:
            for album in artist.albums():
                for track in album.tracks():
                    if track.title.lower() == track_name.lower():
                        print(f"Partial match found (without album): {track.title} in album '{album.title}' by '{artist.title}'")
                        return track

    print(f"No track named '{track_name}' found for artist '{artist_name}' with the specified criteria.")
    return None

# Function to create or update a Plex playlist
def create_or_update_plex_playlist(playlist_name, youtube_tracks):
    existing_playlist = plex.playlist(playlist_name) if playlist_name in [p.title for p in plex.playlists()] else None

    if existing_playlist:
        if args.append:
            print(f"Appending to existing playlist '{playlist_name}'.")
            existing_tracks = existing_playlist.items()
            plex_tracks = [track for track in existing_tracks]
        elif args.replace:
            print(f"Replacing existing playlist '{playlist_name}'.")
            existing_playlist.delete()
            plex_tracks = []
        else:
            sys.exit(f"Warning: Playlist '{playlist_name}' already exists. Specify --append or --replace to proceed.")
    else:
        plex_tracks = []

    unmatched_tracks = []

    for track in youtube_tracks:
        plex_track = find_track_in_plex(track['artist'], track['name'], track['album'])
        if plex_track:
            plex_tracks.append(plex_track)
        else:
            print(f"No match found for '{track['name']}' by '{track['artist']}'. Adding to unmatched list.")
            unmatched_tracks.append({
                "track_name": track['name'],
                "artist_name": track['artist'],
                "album_name": track['album']
            })

    if plex_tracks:
        if existing_playlist and args.append:
            existing_playlist.addItems(plex_tracks)
        else:
            plex.createPlaylist(playlist_name, items=plex_tracks)
        print(f"Plex playlist '{playlist_name}' updated successfully with {len(plex_tracks)} tracks.")
    else:
        print("No matching tracks found in Plex.")

    if args.unmatched_output and unmatched_tracks:
        with open(args.unmatched_output, 'w', newline='') as f:
            if args.unmatched_format == 'csv':
                writer = csv.DictWriter(f, fieldnames=["artist_name", "track_name", "album_name"])
                writer.writeheader()
                writer.writerows(unmatched_tracks)
                print(f"Unmatched YouTube track details saved to {args.unmatched_output} in CSV format.")
            else:
                for track in unmatched_tracks:
                    f.write(track["track_name"] + '\n')
                print(f"Unmatched YouTube track details saved to {args.unmatched_output} in text format.")

# Main execution
if __name__ == "__main__":
    youtube_tracks = get_youtube_music_tracks(args.youtube_playlist_id)
    create_or_update_plex_playlist(args.playlist_name, youtube_tracks)
